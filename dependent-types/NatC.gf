concrete NatC of Nat = open Prelude, Predef in {
  lincat
    Nat = LinNat ;

  linref
    Nat = linNat ;

  lin
    Zero = mkNat "0" ;
    Succ = myPlus1 ;

  -- Proof objects generated by function
  -- : (y : Nat) -> Less Zero (Succ y) ;
  lin LessZ y = y ;
  -- : (x,y : Nat) -> Less x y -> Less (Succ x) (Succ y) ;
  lin LessS = cc3 ;

  -- lin one = mkNat "1" ;
  -- lin two = mkNat "2" ;
  -- lin three = mkNat "3" ;
  -- lin four = mkNat "4" ;

  -- : (m,n : Nat) -> Less m n -> Span ;
  lin FromTo m n _po = {s = linNat m ++ "—" ++ linNat n ++ _po.s} ;

  oper
    LinNat : Type = SS ** {
      valAsUnary : Str ;
      valAsInts : Ints 10
      } ;
    mkNat : Str -> LinNat = \s -> {s = [] ; valAsInts = 0 ; valAsUnary = "0"} ;
    linNat : LinNat -> Str = \n ->
      showInts ! n.valAsInts -- alternative 1: show Ints
      |
      n.valAsUnary           -- alternative 2: show the string, like 0 +1 +1 +1 +1 …
      ;

    myPlus1 : LinNat -> LinNat = \n -> n ** {
      valAsUnary = n.valAsUnary ++ "+1" ;
      valAsInts = plus1ints ! n.valAsInts
    } ;

    plus1ints : Ints 10 => Ints 10 = table {
      10 => 10 ;
      n => Predef.plus n 1
      } ;

    showInts : Ints 10 => Str ;
    showInts = table {
      0 => "0" ; 1 => "1" ; 2 => "2" ;
      3 => "3" ; 4 => "4" ; 5 => "5" ;
      6 => "6" ; 7 => "7" ; 8 => "8" ;
      9 => "9" ; 10 => "10" ;
      _ => "error: too big number"
      } ;
}
